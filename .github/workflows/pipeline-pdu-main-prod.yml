name: "Pipeline: PDA (unified) deploy main to prod"

on:
  workflow_dispatch:
    inputs:
      tag:         { type: string, required: true, description: "Tag to deploy (e.g. 'v1.13.0')" }
      application: { type: choice, required: true, options: [ "provider-data-service" ],
                     default: "provider-data-service", description: "Application to deploy" }
      skip_e2e:    { type: boolean, required: false, default: false, description: "Skip E2E tests after deployment" }

jobs:
  query-staging-version:
    name: "Query staging version"
    permissions: { contents: read }
    runs-on: ubuntu-latest
    environment: staging
    outputs:
      staging_tag: ${{ steps.versions.outputs.staging_tag }}
    steps:
      - uses: actions/checkout@v6

      - name: "Authenticate with Kubernetes cluster"
        id:   kube_auth
        uses: ./.github/actions/cp-kube-auth
        with:
          kube_cert:      ${{ secrets.DPD_KUBE_CERT }}
          kube_cluster:   ${{ secrets.DPD_KUBE_CLUSTER }}
          kube_namespace: ${{ secrets.DPD_KUBE_NAMESPACE }}
          kube_token:     ${{ secrets.DPD_KUBE_TOKEN }}

      - name: "Get deployed image version"
        id:   versions
        if:   steps.kube_auth.outputs.kube_auth_attempted == 'true'
        shell: bash
        env:
          APP: ${{ inputs.application }}
        run: |
          set -eu
          STAGING_TAG=$(kubectl get deploy "${APP}" -o json \
            | jq -r '.spec.template.spec.containers[0].image | split(":")[-1]' || echo "unknown")
          echo "staging_tag=${STAGING_TAG}" >> "$GITHUB_OUTPUT"

  query-prod-version:
    name: "Query prod version"
    permissions: { contents: read }
    runs-on: ubuntu-latest
    environment: prod
    outputs:
      prod_tag: ${{ steps.versions.outputs.prod_tag }}
    steps:
      - uses: actions/checkout@v6

      - name: "Authenticate with Kubernetes cluster"
        id:   kube_auth
        uses: ./.github/actions/cp-kube-auth
        with:
          kube_cert:      ${{ secrets.DPD_KUBE_CERT }}
          kube_cluster:   ${{ secrets.DPD_KUBE_CLUSTER }}
          kube_namespace: ${{ secrets.DPD_KUBE_NAMESPACE }}
          kube_token:     ${{ secrets.DPD_KUBE_TOKEN }}

      - name: "Get deployed image version"
        id:   versions
        if:   steps.kube_auth.outputs.kube_auth_attempted == 'true'
        shell: bash
        env:
          APP: ${{ inputs.application }}
        run: |
          set -eu
          PROD_TAG=$(kubectl get deploy "${APP}" -o json \
            | jq -r '.spec.template.spec.containers[0].image | split(":")[-1]' || echo "unknown")
          echo "prod_tag=${PROD_TAG}" >> "$GITHUB_OUTPUT"

  preflight-summary:
    name: "Preflight"
    needs: [ query-staging-version, query-prod-version ]
    permissions: { contents: read }
    runs-on: ubuntu-latest
    steps:
      - name: "Production deployment"
        run: |
          cat >> "$GITHUB_STEP_SUMMARY" <<'EOF'
          ### Previously-deployed versions
          
          | Environment |                Version currently deployed                |
          |:------------|:--------------------------------------------------------:|
          | **staging** | `${{ needs.query-staging-version.outputs.staging_tag }}` |
          | **prod**    |    `${{ needs.query-prod-version.outputs.prod_tag }}`    |
          
          Unless rolling back, the **staging** version should be similar to the tag to deploy (below) and the **prod** version (above) should be an older tag.
          
          ### Version to be deployed
          
          | Workflow input name                 |       Requested value       |
          |:------------------------------------|:---------------------------:|
          | **Tag to deploy**                   |     `${{ inputs.tag }}`     |
          | **Application to deploy**           | `${{ inputs.application }}` |
          | **Skip E2E tests after deployment** |  `${{ inputs.skip_e2e }}`   |
          
          The image tag `${{ inputs.tag }}` will replace the previous `${{ needs.query-prod-version.outputs.prod_tag }}` version in **prod**.
          
          ### Recommended manual checks
          
          Verify that the tag to deploy and the tag to rollback both still exist in Amazon ECR:
          
          - Log in to [AWS Console](https://justice-cloud-platform.eu.auth0.com/samlp/mQev56oEa7mrRCKAZRxSnDSoYt6Y7r5m?connection=github&region=eu-west-2), navigate to [ECR repositories](https://eu-west-2.console.aws.amazon.com/ecr/private-registry/repositories?region=eu-west-2) and filter by `laa-data-provider-data` to locate the correct repository. 
          - Within the repository, search for tag `${{ inputs.tag }}` and confirm that this image was recently pushed.
          - Search also for the older rollback tag `${{ needs.query-prod-version.outputs.prod_tag }}` to confirm it has not been deleted.
          
          ### Next steps to proceed
          
          Further deployment approval reviews are required to complete this deployment:
          
          - If the information above looks good, approve the **Deploy to prod** job when ready.
          - If the deployment completes successfully, approve the **E2E test prod** job when ready.
          - If there are problems with the newly-deployed version, then roll back by running this pipeline workflow again with **Tag to deploy:** `${{ needs.query-prod-version.outputs.prod_tag }}`.
          EOF

  deploy-prod:
    name: "Deploy to prod"
    needs: [ preflight-summary ]
    permissions: { contents: read, id-token: write }
    uses: ./.github/workflows/rw-pdu-deploy-main.yml
    with:
      application: ${{ inputs.application }}
      tag:         ${{ inputs.tag }}
      target:      "prod"
    secrets: inherit

  e2e-test-prod:
    name: "E2E test prod"
    if:   inputs.skip_e2e != true
    needs: [ deploy-prod ]
    permissions: { contents: read, packages: read }
    uses: ./.github/workflows/rw-pdu-e2etest.yml
    with:
      application: ${{ inputs.application }}
      target:      "prod"
    secrets: inherit
