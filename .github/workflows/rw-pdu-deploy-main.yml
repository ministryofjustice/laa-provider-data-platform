name: "Reusable workflow: PDA (unified) deploy main"

on:
  workflow_call:
    inputs:
      application: { type: string, required: true }
      rtag:        { type: string, required: true }
      target:      { type: string, required: true }
      rel:         { type: string, required: false, default: "" }
  workflow_dispatch:
    inputs:
      application: { type: choice, required: true, options: [ "provider-data-platform" ],
                     description: "Application to deploy" }
      rtag:        { type: string, required: true, description: "Registry tag name (e.g. 'v1.4.2')" }
      target:      { type: choice, required: true, options: [ "dev", "uat", "staging", "prod" ],
                     description: "Target environment" }
      rel:         { type: string, required: false, default: "",
                     description: "Optional release name (leave blank for default)" }

jobs:
  deploy-main:
    name: "Deploy ${{ inputs.application }} registry tag ${{ inputs.rtag }} to ${{ inputs.target }}"
    permissions: { contents: read, id-token: write }
    runs-on: ubuntu-latest
    environment:
      name: ${{ inputs.target }}
      url:  https://laa-provider-data-platform-${{ inputs.target }}.apps.live.cloud-platform.service.justice.gov.uk
    steps:
      - uses: actions/checkout@v6

      - name: "Determine variable values"
        id:   vars
        shell: bash
        env:
          APP:    ${{ inputs.application }}
          REL:    ${{ inputs.rel }}
          TARGET: ${{ inputs.target }}
        run: |
          set -eu
          printf "* inputs.application=%s\n* inputs.rel=%s\n* inputs.target=%s\n" \
              "$APP" "$REL" "$TARGET"
          case "$APP" in
            provider-data-platform)
              CHART=./helm_deploy/provider-data-platform
              PREL=pdp-
              PTAG=pdp-
              STABLE_RELEASE=${PREL}stable
              CANARY_RELEASE=${PREL}canary
              ;;
            *)
              echo "Error: Unknown application: $APP" >&2
              exit 1
              ;;
          esac
          # Use provided release name or default
          if [[ -n "$REL" ]]; then
            RELEASE="${PREL}${REL}"
          else
            RELEASE="$STABLE_RELEASE"
          fi
          # Determine hostname suffix, canary role, and secret name based on release type
          if [[ "${RELEASE}" == "${STABLE_RELEASE}" ]]; then
            # Stable/primary release
            CANARY_ROLE="stable"
            DATACFG_SECRET="app-secrets"
            HOSTNAME_SUFFIX="-1"
          elif [[ "${RELEASE}" == "${CANARY_RELEASE}" ]]; then
            # Canary/secondary release
            CANARY_ROLE="canary"
            DATACFG_SECRET="app-secrets-secondary"
            HOSTNAME_SUFFIX="-2"
          else
            # Other release names - no canary participation
            CANARY_ROLE="none"
            DATACFG_SECRET="app-secrets"
            HOSTNAME_SUFFIX=""
          fi
          printf "* outputs.canary_role=%s\n* outputs.chart=%s\n* outputs.datacfg_secret=%s\n" \
              "$CANARY_ROLE" "$CHART" "$DATACFG_SECRET"
          printf "* outputs.hostname_suffix=%s\n* outputs.ptag=%s\n* outputs.release=%s\n" \
              "$HOSTNAME_SUFFIX" "$PTAG" "$RELEASE"
          echo "canary_role=$CANARY_ROLE" >> "$GITHUB_OUTPUT"
          echo "chart=$CHART" >> "$GITHUB_OUTPUT"
          echo "datacfg_secret=$DATACFG_SECRET" >> "$GITHUB_OUTPUT"
          echo "hostname_suffix=$HOSTNAME_SUFFIX" >> "$GITHUB_OUTPUT"
          echo "ptag=$PTAG" >> "$GITHUB_OUTPUT"
          echo "release=$RELEASE" >> "$GITHUB_OUTPUT"

      - name: "Authenticate with Amazon ECR"  # (needed to get ecr_registry)
        id:   ecr_auth
        uses: ./.github/actions/cp-ecr-auth
        with:
          ecr_region:         ${{ vars.DPD_ECR_REGION }}
          ecr_role_to_assume: ${{ secrets.DPD_ECR_ROLE_TO_ASSUME }}

      - name: "Authenticate with Kubernetes cluster"
        id:   kube_auth
        uses: ./.github/actions/cp-kube-auth
        with:
          kube_cert:      ${{ secrets.DPD_KUBE_CERT }}
          kube_cluster:   ${{ secrets.DPD_KUBE_CLUSTER }}
          kube_namespace: ${{ secrets.DPD_KUBE_NAMESPACE }}
          kube_token:     ${{ secrets.DPD_KUBE_TOKEN }}

      - name: "Install Helm release ${{ steps.vars.outputs.release }}"
        if:   steps.ecr_auth.outputs.ecr_auth_attempted == 'true'
              && steps.kube_auth.outputs.kube_auth_attempted == 'true'
        shell: bash
        env:
          CANARY_ROLE:     ${{ steps.vars.outputs.canary_role }}
          CHART:           ${{ steps.vars.outputs.chart }}
          DATACFG_SECRET:  ${{ steps.vars.outputs.datacfg_secret }}
          HOSTNAME_SUFFIX: ${{ steps.vars.outputs.hostname_suffix }}
          IMAGE:           ${{ steps.ecr_auth.outputs.ecr_registry }}/${{ vars.DPD_ECR_REPOSITORY }}
          PTAG:            ${{ steps.vars.outputs.ptag }}
          RELEASE:         ${{ steps.vars.outputs.release }}
          RTAG:            ${{ inputs.rtag }}
          TARGET:          ${{ inputs.target }}
        run: |
          set -eu
          echo "Upgrade Helm release - canary_role: [${CANARY_ROLE}], chart: [${CHART}], datacfg_secret: [${DATACFG_SECRET}]"
          echo "  hostname_suffix: [${HOSTNAME_SUFFIX}], image: [${IMAGE}], release: [${RELEASE}], tag: [${PTAG}${RTAG}], target: [${TARGET}]"
          PINGDOM_IPS=$(curl -s https://my.pingdom.com/probes/ipv4 | tr -d ' ' | tr '\n' ',' | sed 's/,$//')
          IP_ALLOWLIST="$(kubectl get secret app-secrets -o json | jq -r '.data["IP_ALLOWLIST"] | @base64d'),${PINGDOM_IPS}"
          HELM_OPTS=(
              -f "${CHART}/values.yaml"
              -f "${CHART}/values-${TARGET}.yaml"
              --set-string "canary.role=${CANARY_ROLE}"
              --set-string "hostnameSuffix=${HOSTNAME_SUFFIX}"
              --set-string "image.repository=${IMAGE}"
              --set-string "image.tag=${PTAG}${RTAG}"
              --set-string "ingress.allowlist=${IP_ALLOWLIST//,/\\,}"
              --set-string "secretNames.dataConfig=${DATACFG_SECRET}"
          )
          # For non-stable/primary releases, disable the Grafana dashboard ConfigMap, the ServiceMonitor and the internal Ingress
          if [ "${CANARY_ROLE}" != "stable" ]; then
            HELM_OPTS+=(
                --set ingressInternal.enabled=false
                --set prometheus.metricsEnabled=false
            )
          fi
          helm upgrade --install "${RELEASE}" "${CHART}" "${HELM_OPTS[@]}" --debug --dry-run=server
          # If the dry-run succeeded, do the real thing
          helm upgrade --install "${RELEASE}" "${CHART}" "${HELM_OPTS[@]}"
